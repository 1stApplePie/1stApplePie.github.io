---
layout: single
title: Exhausive Search & Binary Search & Divide and Conquer
categories: Jungle
---

## 완전 탐색(Exhausive Search or Brute Force)
완전 탐샘은 모든 경우의 수를 다 찾아보며 정답을 찾는 것으로 코딩테스트에서 난이도 낮은 완전 탐색 문제를 만났을 때 편하게 풀었던 기억이 있다.<br>

### 완전 탐색 기법
* Brute-Force
* 비트마스크
* 재귀 함수
* 순열
* BFS/DFS

### 단순 완전 탐색(Brute-Force)
* for, while등 모든 case를 만들어 답을 구하는 법. 위에서 편하게 풀었다고 서술했던 기법
* 효율성 측면에서 다른 효율적인 방식이 있는 경우가 대부분이기 때문에 잘 쓰이지 않음

### 비트마스크(Bitmask)
* 컴퓨터 연산인 2진수를 이용하는 방법
* 비트마스크는 완전 탐색의 모든 경우의 수가 요소가 포함 되거나, 포함되지 않는 두 가지로 나뉘는 경우에 유용함
* 이진 연산을 이용하기 때문에 빠른 계산 속도가 장점


### 재귀 함수(Recursion Function)
* 이전 포스트에 올렸던 재귀 함수를 이용하는 방법
* 완전 탐색에서 재귀 함수의 활용은 이전 결과를 기억하는 것이 아닌 해결가능한 방법을 모두 탐색하는 것

### 순열(permutation)
* 서로 다른 n개를 일렬로 나열하는 경우의 수는 n!임을 활용
* n!이 결코 작은 경우의 수가 아니므로 n이 작은 경우에 사용하면 유용함

### 너비 우선 탐색 / 깊이 우선 탐색(BFS/DFS)
* 깊이 우선 탐색: 루트 노드에서 시작하여 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
* 너비 우선 탐색: 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법

### Note
각 기법이 어떻게 작동하는지 읽는것만으로는 이해가 잘 가지 않았다. 어떤 예제가 있는지, 어떤 식으로 작동하는지 찾아가며 학습하는것을 추천한다.

## 이분 탐색
정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 법<br>
문장에서 눈에 띄듯 정렬되어 있는 리스트가 포인트이다.



## 분할 정복
분할, 정복, 조합의 단계로 문제를 나눠가며 풀고 다시 합쳐서 해결하는 여러 알고리즘의 기본이 되는 해결 방법<br>
재귀 함수로 자신을 호출하면서 그 연산의 단위를 조금씩 줄여가는데, 여기서 최소 두 개의 하위 문제가 생성되므로 재귀 함수 호출이 여러번 일어난다.<br>
분할된 문제들은 기존의 문제를 분할한 것으로 중복이 없어 서로 독립적이고, 재귀 함수의 성질을 갖기 때문에 코드가 직관적이라는 장점이 있다.<br>
단점은 재귀 함수의 단점을 그대로 끌어안게 된다.<br>
이진 탐색, 정렬에서 공부한 합병 정렬, 퀵정렬이 분할 정복의 대표적인 예로 많이 소개되므로 참고하길 바란다.